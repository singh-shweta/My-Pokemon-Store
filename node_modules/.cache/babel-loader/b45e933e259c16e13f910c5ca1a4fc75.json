{"ast":null,"code":"import { __rest } from \"tslib\";\nimport equal from \"@wry/equality\";\nimport { createFragmentMap, getFragmentDefinitions, getFragmentFromSelection, getMainDefinition, isField, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(query, _a, _b, variables) {\n  var aData = _a.data,\n    aRest = __rest(_a, [\"data\"]);\n  var bData = _b.data,\n    bRest = __rest(_b, [\"data\"]);\n  return equal(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n    variables: variables\n  });\n}\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n  if (aResult === bResult) {\n    return true;\n  }\n  var seenSelections = new Set();\n  // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n  return selectionSet.selections.every(function (selection) {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection);\n    // Ignore @skip(if: true) and @include(if: false) fields.\n    if (!shouldInclude(selection, context.variables)) return true;\n    // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n    if (selectionHasNonreactiveDirective(selection)) return true;\n    if (isField(selection)) {\n      var resultKey = resultKeyNameFromField(selection);\n      var aResultChild = aResult && aResult[resultKey];\n      var bResultChild = bResult && bResult[resultKey];\n      var childSelectionSet = selection.selectionSet;\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n      var aChildIsArray = Array.isArray(aResultChild);\n      var bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n      if (aChildIsArray && bChildIsArray) {\n        var length_1 = aResultChild.length;\n        if (bResultChild.length !== length_1) {\n          return false;\n        }\n        for (var i = 0; i < length_1; ++i) {\n          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n    } else {\n      var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n        return equalBySelectionSet(fragment.selectionSet,\n        // Notice that we reuse the same aResult and bResult values here,\n        // since the fragment ...spread does not specify a field name, but\n        // consists of multiple fields (within the fragment's selection set)\n        // that should be applied to the current result value(s).\n        aResult, bResult, context);\n      }\n    }\n  });\n}\nfunction selectionHasNonreactiveDirective(selection) {\n  return !!selection.directives && selection.directives.some(directiveIsNonreactive);\n}\nfunction directiveIsNonreactive(dir) {\n  return dir.name.value === \"nonreactive\";\n}","map":{"version":3,"sources":["../../src/core/equalByQuery.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,MAAM,eAAe;AAgBjC,SACE,iBAAiB,EACjB,sBAAsB,EACtB,wBAAwB,EACxB,iBAAiB,EACjB,OAAO,EACP,sBAAsB,EACtB,aAAa,QACR,uBAAuB;AAE9B;AACA;AACA,OAAM,SAAU,YAAY,CAC1B,KAAmB,EACnB,EAA8D,EAC9D,EAA8D,EAC9D,SAA8B,EAAA;EAF5B,IAAM,KAAK,GAAA,EAAA,CAAA,IAAA;IAAK,KAAK,GAAA,MAAA,CAAA,EAAA,EAAvB,CAAA,MAAA,CAAyB,CAAF;MACf,KAAK,GAAA,EAAA,CAAA,IAAA;IAAK,KAAK,GAAA,MAAA,CAAA,EAAA,EAAvB,CAAA,MAAA,CAAyB,CAAF;EAGvB,OACE,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,IACnB,mBAAmB,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE;IACvE,WAAW,EAAE,iBAAiB,CAAC,sBAAsB,CAAC,KAAK,CAAC,CAAC;IAC7D,SAAS,EAAA;GACV,CAAC;AAEN;AASA,SAAS,mBAAmB,CAC1B,YAA8B,EAC9B,OAAY,EACZ,OAAY,EACZ,OAA2C,EAAA;EAE3C,IAAI,OAAO,KAAK,OAAO,EAAE;IACvB,OAAO,IAAI;EACb;EAEA,IAAM,cAAc,GAAG,IAAI,GAAG,CAAA,CAAiB;EAE/C;EACA;EACA;EACA,OAAO,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC,UAAC,SAAS,EAAA;IAC7C;IACA;IACA,IAAI,cAAc,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,OAAO,IAAI;IAC9C,cAAc,CAAC,GAAG,CAAC,SAAS,CAAC;IAE7B;IACA,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,SAAS,CAAC,EAAE,OAAO,IAAI;IAE7D;IACA;IACA,IAAI,gCAAgC,CAAC,SAAS,CAAC,EAAE,OAAO,IAAI;IAE5D,IAAI,OAAO,CAAC,SAAS,CAAC,EAAE;MACtB,IAAM,SAAS,GAAG,sBAAsB,CAAC,SAAS,CAAC;MACnD,IAAM,YAAY,GAAG,OAAO,IAAI,OAAO,CAAC,SAAS,CAAC;MAClD,IAAM,YAAY,GAAG,OAAO,IAAI,OAAO,CAAC,SAAS,CAAC;MAClD,IAAM,iBAAiB,GAAG,SAAS,CAAC,YAAY;MAEhD,IAAI,CAAC,iBAAiB,EAAE;QACtB;QACA;QACA,OAAO,KAAK,CAAC,YAAY,EAAE,YAAY,CAAC;MAC1C;MAEA,IAAM,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC;MACjD,IAAM,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC;MACjD,IAAI,aAAa,KAAK,aAAa,EAAE,OAAO,KAAK;MACjD,IAAI,aAAa,IAAI,aAAa,EAAE;QAClC,IAAM,QAAM,GAAG,YAAY,CAAC,MAAM;QAClC,IAAI,YAAY,CAAC,MAAM,KAAK,QAAM,EAAE;UAClC,OAAO,KAAK;QACd;QACA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAM,EAAE,EAAE,CAAC,EAAE;UAC/B,IACE,CAAC,mBAAmB,CAClB,iBAAiB,EACjB,YAAY,CAAC,CAAC,CAAC,EACf,YAAY,CAAC,CAAC,CAAC,EACf,OAAO,CACR,EACD;YACA,OAAO,KAAK;UACd;QACF;QACA,OAAO,IAAI;MACb;MAEA,OAAO,mBAAmB,CACxB,iBAAiB,EACjB,YAAY,EACZ,YAAY,EACZ,OAAO,CACR;IACH,CAAC,MAAM;MACL,IAAM,QAAQ,GAAG,wBAAwB,CAAC,SAAS,EAAE,OAAO,CAAC,WAAW,CAAC;MACzE,IAAI,QAAQ,EAAE;QACZ;QACA;QACA,IAAI,gCAAgC,CAAC,QAAQ,CAAC,EAAE,OAAO,IAAI;QAE3D,OAAO,mBAAmB,CACxB,QAAQ,CAAC,YAAY;QACrB;QACA;QACA;QACA;QACA,OAAO,EACP,OAAO,EACP,OAAO,CACR;MACH;IACF;EACF,CAAC,CAAC;AACJ;AAEA,SAAS,gCAAgC,CACvC,SAI0B,EAAA;EAE1B,OACE,CAAC,CAAC,SAAS,CAAC,UAAU,IAAI,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,sBAAsB,CAAC;AAE/E;AAEA,SAAS,sBAAsB,CAAC,GAAkB,EAAA;EAChD,OAAO,GAAG,CAAC,IAAI,CAAC,KAAK,KAAK,aAAa;AACzC","sourcesContent":["import equal from \"@wry/equality\";\n\nimport type {\n  DirectiveNode,\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  SelectionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { ApolloQueryResult, OperationVariables } from \"./types.js\";\n\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getFragmentFromSelection,\n  getMainDefinition,\n  isField,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\n\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(\n  query: DocumentNode,\n  { data: aData, ...aRest }: Partial<ApolloQueryResult<unknown>>,\n  { data: bData, ...bRest }: Partial<ApolloQueryResult<unknown>>,\n  variables?: OperationVariables\n): boolean {\n  return (\n    equal(aRest, bRest) &&\n    equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n      fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n      variables,\n    })\n  );\n}\n\n// Encapsulates the information used by equalBySelectionSet that does not change\n// during the recursion.\ninterface CompareContext<TVariables> {\n  fragmentMap: FragmentMap;\n  variables: TVariables | undefined;\n}\n\nfunction equalBySelectionSet(\n  selectionSet: SelectionSetNode,\n  aResult: any,\n  bResult: any,\n  context: CompareContext<OperationVariables>\n): boolean {\n  if (aResult === bResult) {\n    return true;\n  }\n\n  const seenSelections = new Set<SelectionNode>();\n\n  // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n  return selectionSet.selections.every((selection) => {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection);\n\n    // Ignore @skip(if: true) and @include(if: false) fields.\n    if (!shouldInclude(selection, context.variables)) return true;\n\n    // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n    if (selectionHasNonreactiveDirective(selection)) return true;\n\n    if (isField(selection)) {\n      const resultKey = resultKeyNameFromField(selection);\n      const aResultChild = aResult && aResult[resultKey];\n      const bResultChild = bResult && bResult[resultKey];\n      const childSelectionSet = selection.selectionSet;\n\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n\n      const aChildIsArray = Array.isArray(aResultChild);\n      const bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n      if (aChildIsArray && bChildIsArray) {\n        const length = aResultChild.length;\n        if (bResultChild.length !== length) {\n          return false;\n        }\n        for (let i = 0; i < length; ++i) {\n          if (\n            !equalBySelectionSet(\n              childSelectionSet,\n              aResultChild[i],\n              bResultChild[i],\n              context\n            )\n          ) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      return equalBySelectionSet(\n        childSelectionSet,\n        aResultChild,\n        bResultChild,\n        context\n      );\n    } else {\n      const fragment = getFragmentFromSelection(selection, context.fragmentMap);\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n\n        return equalBySelectionSet(\n          fragment.selectionSet,\n          // Notice that we reuse the same aResult and bResult values here,\n          // since the fragment ...spread does not specify a field name, but\n          // consists of multiple fields (within the fragment's selection set)\n          // that should be applied to the current result value(s).\n          aResult,\n          bResult,\n          context\n        );\n      }\n    }\n  });\n}\n\nfunction selectionHasNonreactiveDirective(\n  selection:\n    | FieldNode\n    | InlineFragmentNode\n    | FragmentSpreadNode\n    | FragmentDefinitionNode\n): boolean {\n  return (\n    !!selection.directives && selection.directives.some(directiveIsNonreactive)\n  );\n}\n\nfunction directiveIsNonreactive(dir: DirectiveNode): boolean {\n  return dir.name.value === \"nonreactive\";\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}