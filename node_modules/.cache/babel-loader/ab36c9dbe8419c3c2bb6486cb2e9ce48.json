{"ast":null,"code":"import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet } from \"./helpers.js\";\nconst EntryMethods = {\n  setDirty: true,\n  dispose: true,\n  forget: true // Fully remove parent Entry from LRU cache and computation graph\n};\nexport function dep(options) {\n  const depsByKey = new Map();\n  const subscribe = options && options.subscribe;\n  function depend(key) {\n    const parent = parentEntrySlot.getValue();\n    if (parent) {\n      let dep = depsByKey.get(key);\n      if (!dep) {\n        depsByKey.set(key, dep = new Set());\n      }\n      parent.dependOn(dep);\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(dep);\n        dep.unsubscribe = subscribe(key);\n      }\n    }\n  }\n  depend.dirty = function dirty(key, entryMethodName) {\n    const dep = depsByKey.get(key);\n    if (dep) {\n      const m = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : \"setDirty\";\n      // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n      // because modifying a Set while iterating over it can cause elements in\n      // the Set to be removed from the Set before they've been iterated over.\n      arrayFromSet(dep).forEach(entry => entry[m]());\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n  return depend;\n}","map":{"version":3,"sources":["../src/dep.ts"],"names":[],"mappings":"AAEA,SAAS,eAAe,QAAQ,cAAc;AAC9C,SACE,cAAc,EAEd,gBAAgB,EAChB,YAAY,QACN,cAAc;AAGtB,MAAM,YAAY,GAAG;EACnB,QAAQ,EAAE,IAAI;EACd,OAAO,EAAE,IAAI;EACb,MAAM,EAAE,IAAI,CAAI;CACjB;AAWD,OAAM,SAAU,GAAG,CAAO,OAEzB,EAAA;EACC,MAAM,SAAS,GAAG,IAAI,GAAG,CAAA,CAAmB;EAC5C,MAAM,SAAS,GAAG,OAAO,IAAI,OAAO,CAAC,SAAS;EAE9C,SAAS,MAAM,CAAC,GAAS,EAAA;IACvB,MAAM,MAAM,GAAG,eAAe,CAAC,QAAQ,CAAA,CAAE;IACzC,IAAI,MAAM,EAAE;MACV,IAAI,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC;MAC5B,IAAI,CAAC,GAAG,EAAE;QACR,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,IAAI,GAAgB,CAAhB,CAAgB,CAAC;MAC/C;MACD,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC;MACpB,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;QACnC,gBAAgB,CAAC,GAAG,CAAC;QACrB,GAAG,CAAC,WAAW,GAAG,SAAS,CAAC,GAAG,CAAC;MACjC;IACF;EACH;EAEA,MAAM,CAAC,KAAK,GAAG,SAAS,KAAK,CAC3B,GAAS,EACT,eAAiC,EAAA;IAEjC,MAAM,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC;IAC9B,IAAI,GAAG,EAAE;MACP,MAAM,CAAC,GACL,eAAe,IACf,cAAc,CAAC,IAAI,CAAC,YAAY,EAAE,eAAe,CAAC,GAChD,eAAe,GAAG,UAAU;MAChC;MACA;MACA;MACA,YAAY,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,CAAC,CAAC,CAAA,CAAE,CAAC;MAC9C,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC;MACrB,gBAAgB,CAAC,GAAG,CAAC;IACtB;EACH,CAAC;EAED,OAAO,MAA4C;AACrD","sourceRoot":"","sourcesContent":["import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet, } from \"./helpers.js\";\nconst EntryMethods = {\n    setDirty: true,\n    dispose: true,\n    forget: true, // Fully remove parent Entry from LRU cache and computation graph\n};\nexport function dep(options) {\n    const depsByKey = new Map();\n    const subscribe = options && options.subscribe;\n    function depend(key) {\n        const parent = parentEntrySlot.getValue();\n        if (parent) {\n            let dep = depsByKey.get(key);\n            if (!dep) {\n                depsByKey.set(key, dep = new Set);\n            }\n            parent.dependOn(dep);\n            if (typeof subscribe === \"function\") {\n                maybeUnsubscribe(dep);\n                dep.unsubscribe = subscribe(key);\n            }\n        }\n    }\n    depend.dirty = function dirty(key, entryMethodName) {\n        const dep = depsByKey.get(key);\n        if (dep) {\n            const m = (entryMethodName &&\n                hasOwnProperty.call(EntryMethods, entryMethodName)) ? entryMethodName : \"setDirty\";\n            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n            // because modifying a Set while iterating over it can cause elements in\n            // the Set to be removed from the Set before they've been iterated over.\n            arrayFromSet(dep).forEach(entry => entry[m]());\n            depsByKey.delete(key);\n            maybeUnsubscribe(dep);\n        }\n    };\n    return depend;\n}\n//# sourceMappingURL=dep.js.map"]},"metadata":{},"sourceType":"module"}