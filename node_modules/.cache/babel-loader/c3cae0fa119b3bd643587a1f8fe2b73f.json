{"ast":null,"code":"import { Slot } from \"./slot.js\";\nexport { Slot };\nexport const {\n  bind,\n  noContext\n} = Slot;\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback, delay) {\n  return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen(genFn) {\n  return function () {\n    const gen = genFn.apply(this, arguments);\n    const boundNext = bind(gen.next);\n    const boundThrow = bind(gen.throw);\n    return new Promise((resolve, reject) => {\n      function invoke(method, argument) {\n        try {\n          var result = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n        const next = result.done ? resolve : invokeNext;\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n      const invokeNext = value => invoke(boundNext, value);\n      const invokeThrow = error => invoke(boundThrow, error);\n      invokeNext();\n    });\n  };\n}\nfunction isPromiseLike(value) {\n  return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers = [];\nexport function wrapYieldingFiberMethods(Fiber) {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    const wrap = (obj, method) => {\n      const fn = obj[method];\n      obj[method] = function () {\n        return noContext(fn, arguments, this);\n      };\n    };\n    // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n  return Fiber;\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"AAAA,SAAS,IAAI,QAAQ,WAAW;AAChC,SAAS,IAAI;AACb,OAAO,MAAM;EAAE,IAAI;EAAE;AAAS,CAAE,GAAG,IAAI;AAUvC;AACA,SAAS,qBAAqB,IAAI,UAAU;AAC5C,SAAS,qBAAqB,CAAC,QAAmB,EAAE,KAAa,EAAA;EAC/D,OAAO,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,KAAK,CAAC;AAC1C;AAEA;AACA;AACA,OAAM,SAAU,YAAY,CAM1B,KAA4D,EAAA;EAE5D,OAAO,YAAA;IACL,MAAM,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,SAAgB,CAAC;IAO/C,MAAM,SAAS,GAAW,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;IACxC,MAAM,UAAU,GAAW,IAAI,CAAC,GAAG,CAAC,KAAM,CAAC;IAE3C,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAI;MACrC,SAAS,MAAM,CAAC,MAAc,EAAE,QAAa,EAAA;QAC3C,IAAI;UACF,IAAI,MAAM,GAAQ,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC;SAC7C,CAAC,OAAO,KAAK,EAAE;UACd,OAAO,MAAM,CAAC,KAAK,CAAC;QACrB;QACD,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,GAAG,OAAO,GAAG,UAAU;QAC/C,IAAI,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;UAC/B,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,GAAG,MAAM,GAAG,WAAW,CAAC;SAC5D,MAAM;UACL,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;QACnB;MACH;MACA,MAAM,UAAU,GAAI,KAAW,IAAK,MAAM,CAAC,SAAS,EAAE,KAAK,CAAC;MAC5D,MAAM,WAAW,GAAI,KAAU,IAAK,MAAM,CAAC,UAAU,EAAE,KAAK,CAAC;MAC7D,UAAU,CAAA,CAAE;IACd,CAAC,CAAC;EACJ,CAAqC;AACvC;AAEA,SAAS,aAAa,CAAC,KAAU,EAAA;EAC/B,OAAO,KAAK,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,UAAU;AAClD;AAEA;AACA;AACA;AACA,MAAM,aAAa,GAAe,EAAE;AACpC,OAAM,SAAU,wBAAwB,CAAqB,KAAQ,EAAA;EACnE;EACA;EACA,IAAI,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;IACpC,MAAM,IAAI,GAAG,CAAC,GAAQ,EAAE,MAAc,KAAI;MACxC,MAAM,EAAE,GAAG,GAAG,CAAC,MAAM,CAAC;MACtB,GAAG,CAAC,MAAM,CAAC,GAAG,YAAA;QACZ,OAAO,SAAS,CAAC,EAAE,EAAE,SAAgB,EAAE,IAAI,CAAC;MAC9C,CAAC;IACH,CAAC;IACD;IACA;IACA,IAAI,CAAC,KAAK,EAAE,OAAO,CAAC;IACpB,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,KAAK,CAAC;IAC5B,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,WAAW,CAAC;IAClC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC;EAC1B;EACD,OAAO,KAAK;AACd","sourceRoot":"","sourcesContent":["import { Slot } from \"./slot.js\";\nexport { Slot };\nexport const { bind, noContext } = Slot;\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback, delay) {\n    return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen(genFn) {\n    return function () {\n        const gen = genFn.apply(this, arguments);\n        const boundNext = bind(gen.next);\n        const boundThrow = bind(gen.throw);\n        return new Promise((resolve, reject) => {\n            function invoke(method, argument) {\n                try {\n                    var result = method.call(gen, argument);\n                }\n                catch (error) {\n                    return reject(error);\n                }\n                const next = result.done ? resolve : invokeNext;\n                if (isPromiseLike(result.value)) {\n                    result.value.then(next, result.done ? reject : invokeThrow);\n                }\n                else {\n                    next(result.value);\n                }\n            }\n            const invokeNext = (value) => invoke(boundNext, value);\n            const invokeThrow = (error) => invoke(boundThrow, error);\n            invokeNext();\n        });\n    };\n}\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers = [];\nexport function wrapYieldingFiberMethods(Fiber) {\n    // There can be only one implementation of Fiber per process, so this array\n    // should never grow longer than one element.\n    if (wrappedFibers.indexOf(Fiber) < 0) {\n        const wrap = (obj, method) => {\n            const fn = obj[method];\n            obj[method] = function () {\n                return noContext(fn, arguments, this);\n            };\n        };\n        // These methods can yield, according to\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n        wrap(Fiber, \"yield\");\n        wrap(Fiber.prototype, \"run\");\n        wrap(Fiber.prototype, \"throwInto\");\n        wrappedFibers.push(Fiber);\n    }\n    return Fiber;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}