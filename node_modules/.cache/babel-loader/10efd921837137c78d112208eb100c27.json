{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\nvar LocalState = /** @class */function () {\n  function LocalState(_a) {\n    var cache = _a.cache,\n      client = _a.client,\n      resolvers = _a.resolvers,\n      fragmentMatcher = _a.fragmentMatcher;\n    this.selectionsToResolveCache = new WeakMap();\n    this.cache = cache;\n    if (client) {\n      this.client = client;\n    }\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n  LocalState.prototype.addResolvers = function (resolvers) {\n    var _this = this;\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(function (resolverGroup) {\n        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  };\n  LocalState.prototype.setResolvers = function (resolvers) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  };\n  LocalState.prototype.getResolvers = function () {\n    return this.resolvers || {};\n  };\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  LocalState.prototype.runResolvers = function (_a) {\n    return __awaiter(this, arguments, void 0, function (_b) {\n      var document = _b.document,\n        remoteResult = _b.remoteResult,\n        context = _b.context,\n        variables = _b.variables,\n        _c = _b.onlyRunForcedResolvers,\n        onlyRunForcedResolvers = _c === void 0 ? false : _c;\n      return __generator(this, function (_d) {\n        if (document) {\n          return [2 /*return*/, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) {\n            return __assign(__assign({}, remoteResult), {\n              data: localResult.result\n            });\n          })];\n        }\n        return [2 /*return*/, remoteResult];\n      });\n    });\n  };\n  LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  };\n  LocalState.prototype.getFragmentMatcher = function () {\n    return this.fragmentMatcher;\n  };\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  LocalState.prototype.clientQuery = function (document) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  };\n  // Server queries are stripped of all @client based selection sets.\n  LocalState.prototype.serverQuery = function (document) {\n    return removeClientSetsFromDocument(document);\n  };\n  LocalState.prototype.prepareContext = function (context) {\n    var cache = this.cache;\n    return __assign(__assign({}, context), {\n      cache: cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: function (obj) {\n        return cache.identify(obj);\n      }\n    });\n  };\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  LocalState.prototype.addExportedVariables = function (document_1) {\n    return __awaiter(this, arguments, void 0, function (document, variables, context) {\n      if (variables === void 0) {\n        variables = {};\n      }\n      if (context === void 0) {\n        context = {};\n      }\n      return __generator(this, function (_a) {\n        if (document) {\n          return [2 /*return*/, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) {\n            return __assign(__assign({}, variables), data.exportedVariables);\n          })];\n        }\n        return [2 /*return*/, __assign({}, variables)];\n      });\n    });\n  };\n  LocalState.prototype.shouldForceResolvers = function (document) {\n    var forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter: function (node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(function (arg) {\n              return arg.name.value === \"always\" && arg.value.kind === \"BooleanValue\" && arg.value.value === true;\n            });\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        }\n      }\n    });\n    return forceResolvers;\n  };\n  // Query the cache and return matching data.\n  LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables: variables,\n      returnPartialData: true,\n      optimistic: false\n    }).result;\n  };\n  LocalState.prototype.resolveDocument = function (document_1, rootValue_1) {\n    return __awaiter(this, arguments, void 0, function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n      var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\n      if (context === void 0) {\n        context = {};\n      }\n      if (variables === void 0) {\n        variables = {};\n      }\n      if (fragmentMatcher === void 0) {\n        fragmentMatcher = function () {\n          return true;\n        };\n      }\n      if (onlyRunForcedResolvers === void 0) {\n        onlyRunForcedResolvers = false;\n      }\n      return __generator(this, function (_b) {\n        mainDefinition = getMainDefinition(document);\n        fragments = getFragmentDefinitions(document);\n        fragmentMap = createFragmentMap(fragments);\n        selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n        definitionOperation = mainDefinition.operation;\n        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : \"Query\";\n        _a = this, cache = _a.cache, client = _a.client;\n        execContext = {\n          fragmentMap: fragmentMap,\n          context: __assign(__assign({}, context), {\n            cache: cache,\n            client: client\n          }),\n          variables: variables,\n          fragmentMatcher: fragmentMatcher,\n          defaultOperationType: defaultOperationType,\n          exportedVariables: {},\n          selectionsToResolve: selectionsToResolve,\n          onlyRunForcedResolvers: onlyRunForcedResolvers\n        };\n        isClientFieldDescendant = false;\n        return [2 /*return*/, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (result) {\n          return {\n            result: result,\n            exportedVariables: execContext.exportedVariables\n          };\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveSelectionSet = function (selectionSet, isClientFieldDescendant, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fragmentMap, context, variables, resultsToMerge, execute;\n      var _this = this;\n      return __generator(this, function (_a) {\n        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n        resultsToMerge = [rootValue];\n        execute = function (selection) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var fragment, typeCondition;\n            return __generator(this, function (_a) {\n              if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {\n                // Skip selections without @client directives\n                // (still processing if one of the ancestors or one of the child fields has @client directive)\n                return [2 /*return*/];\n              }\n              if (!shouldInclude(selection, variables)) {\n                // Skip this entirely.\n                return [2 /*return*/];\n              }\n              if (isField(selection)) {\n                return [2 /*return*/, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function (fieldResult) {\n                  var _a;\n                  if (typeof fieldResult !== \"undefined\") {\n                    resultsToMerge.push((_a = {}, _a[resultKeyNameFromField(selection)] = fieldResult, _a));\n                  }\n                })];\n              }\n              if (isInlineFragment(selection)) {\n                fragment = selection;\n              } else {\n                // This is a named fragment.\n                fragment = fragmentMap[selection.name.value];\n                invariant(fragment, 18, selection.name.value);\n              }\n              if (fragment && fragment.typeCondition) {\n                typeCondition = fragment.typeCondition.name.value;\n                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                  return [2 /*return*/, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (fragmentResult) {\n                    resultsToMerge.push(fragmentResult);\n                  })];\n                }\n              }\n              return [2 /*return*/];\n            });\n          });\n        };\n        return [2 /*return*/, Promise.all(selectionSet.selections.map(execute)).then(function () {\n          return mergeDeepArray(resultsToMerge);\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveField = function (field, isClientFieldDescendant, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n      var _this = this;\n      return __generator(this, function (_a) {\n        if (!rootValue) {\n          return [2 /*return*/, null];\n        }\n        variables = execContext.variables;\n        fieldName = field.name.value;\n        aliasedFieldName = resultKeyNameFromField(field);\n        aliasUsed = fieldName !== aliasedFieldName;\n        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n        resultPromise = Promise.resolve(defaultResult);\n        // Usually all local resolvers are run when passing through here, but\n        // if we've specifically identified that we only want to run forced\n        // resolvers (that is, resolvers for fields marked with\n        // `@client(always: true)`), then we'll skip running non-forced resolvers.\n        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {\n          resolverType = rootValue.__typename || execContext.defaultOperationType;\n          resolverMap = this.resolvers && this.resolvers[resolverType];\n          if (resolverMap) {\n            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n            if (resolve) {\n              resultPromise = Promise.resolve(\n              // In case the resolve function accesses reactive variables,\n              // set cacheSlot to the current cache instance.\n              cacheSlot.withValue(this.cache, resolve, [rootValue, argumentsObjectFromField(field, variables), execContext.context, {\n                field: field,\n                fragmentMap: execContext.fragmentMap\n              }]));\n            }\n          }\n        }\n        return [2 /*return*/, resultPromise.then(function (result) {\n          var _a, _b;\n          if (result === void 0) {\n            result = defaultResult;\n          }\n          // If an @export directive is associated with the current field, store\n          // the `as` export variable name and current result for later use.\n          if (field.directives) {\n            field.directives.forEach(function (directive) {\n              if (directive.name.value === \"export\" && directive.arguments) {\n                directive.arguments.forEach(function (arg) {\n                  if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                    execContext.exportedVariables[arg.value.value] = result;\n                  }\n                });\n              }\n            });\n          }\n          // Handle all scalar types here.\n          if (!field.selectionSet) {\n            return result;\n          }\n          // From here down, the field has a selection set, which means it's trying\n          // to query a GraphQLObjectType.\n          if (result == null) {\n            // Basically any field in a GraphQL response can be null, or missing\n            return result;\n          }\n          var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function (d) {\n            return d.name.value === \"client\";\n          })) !== null && _b !== void 0 ? _b : false;\n          if (Array.isArray(result)) {\n            return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n          }\n          // Returned value is an object, and the query has a sub-selection. Recurse.\n          if (field.selectionSet) {\n            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\n          }\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveSubSelectedArray = function (field, isClientFieldDescendant, result, execContext) {\n    var _this = this;\n    return Promise.all(result.map(function (item) {\n      if (item === null) {\n        return null;\n      }\n      // This is a nested array, recurse.\n      if (Array.isArray(item)) {\n        return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n      }\n      // This is an object, run the selection set on it.\n      if (field.selectionSet) {\n        return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n      }\n    }));\n  };\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  LocalState.prototype.collectSelectionsToResolve = function (mainDefinition, fragmentMap) {\n    var isSingleASTNode = function (node) {\n      return !Array.isArray(node);\n    };\n    var selectionsToResolveCache = this.selectionsToResolveCache;\n    function collectByDefinition(definitionNode) {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        var matches_1 = new Set();\n        selectionsToResolveCache.set(definitionNode, matches_1);\n        visit(definitionNode, {\n          Directive: function (node, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach(function (node) {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches_1.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread: function (spread, _, __, ___, ancestors) {\n            var fragment = fragmentMap[spread.name.value];\n            invariant(fragment, 19, spread.name.value);\n            var fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach(function (node) {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches_1.add(node);\n                }\n              });\n              matches_1.add(spread);\n              fragmentSelections.forEach(function (selection) {\n                matches_1.add(selection);\n              });\n            }\n          }\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode);\n    }\n    return collectByDefinition(mainDefinition);\n  };\n  return LocalState;\n}();\nexport { LocalState };","map":{"version":3,"sources":["../../src/core/LocalState.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant } from \"../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n  DirectiveNode,\n  FragmentSpreadNode,\n  ExecutableDefinitionNode,\n} from \"graphql\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\n\nimport type { ApolloCache } from \"../cache/index.js\";\nimport type { FragmentMap, StoreObject } from \"../utilities/index.js\";\nimport {\n  argumentsObjectFromField,\n  buildQueryFromSelectionSet,\n  createFragmentMap,\n  getFragmentDefinitions,\n  getMainDefinition,\n  hasDirectives,\n  isField,\n  isInlineFragment,\n  mergeDeep,\n  mergeDeepArray,\n  removeClientSetsFromDocument,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport type { Resolvers, OperationVariables } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  }\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n  selectionsToResolve: Set<SelectionNode>;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client?: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher?: FragmentMatcher;\n  private selectionsToResolveCache = new WeakMap<\n    ExecutableDefinitionNode,\n    Set<SelectionNode>\n  >();\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach((resolverGroup) => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers\n      ).then((localResult) => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher | undefined {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return removeClientSetsFromDocument(document);\n  }\n\n  public prepareContext(context?: Record<string, any>) {\n    const { cache } = this;\n    return {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey(obj: StoreObject) {\n        return cache.identify(obj);\n      },\n    };\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables<TVars extends OperationVariables>(\n    document: DocumentNode,\n    variables: TVars = {} as TVars,\n    context = {}\n  ): /* returns at least the variables that were passed in */ Promise<TVars> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables\n      ).then((data) => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(\n              (arg) =>\n                arg.name.value === \"always\" &&\n                arg.value.kind === \"BooleanValue\" &&\n                arg.value.value === true\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false\n  ) {\n    const mainDefinition = getMainDefinition(\n      document\n    ) as OperationDefinitionNode;\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n    const selectionsToResolve = this.collectSelectionsToResolve(\n      mainDefinition,\n      fragmentMap\n    );\n\n    const definitionOperation = mainDefinition.operation;\n\n    const defaultOperationType =\n      definitionOperation ?\n        definitionOperation.charAt(0).toUpperCase() +\n        definitionOperation.slice(1)\n      : \"Query\";\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      selectionsToResolve,\n      onlyRunForcedResolvers,\n    };\n    const isClientFieldDescendant = false;\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      isClientFieldDescendant,\n      rootValue,\n      execContext\n    ).then((result) => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    isClientFieldDescendant: boolean,\n    rootValue: TData,\n    execContext: ExecContext\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (\n        !isClientFieldDescendant &&\n        !execContext.selectionsToResolve.has(selection)\n      ) {\n        // Skip selections without @client directives\n        // (still processing if one of the ancestors or one of the child fields has @client directive)\n        return;\n      }\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(\n          selection,\n          isClientFieldDescendant,\n          rootValue,\n          execContext\n        ).then((fieldResult) => {\n          if (typeof fieldResult !== \"undefined\") {\n            resultsToMerge.push({\n              [resultKeyNameFromField(selection)]: fieldResult,\n            } as TData);\n          }\n        });\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named %s`, selection.name.value);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            isClientFieldDescendant,\n            rootValue,\n            execContext\n          ).then((fragmentResult) => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function () {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    rootValue: any,\n    execContext: ExecContext\n  ): Promise<any> {\n    if (!rootValue) {\n      return null;\n    }\n\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(\n            // In case the resolve function accesses reactive variables,\n            // set cacheSlot to the current cache instance.\n            cacheSlot.withValue(this.cache, resolve, [\n              rootValue,\n              argumentsObjectFromField(field, variables),\n              execContext.context,\n              { field, fragmentMap: execContext.fragmentMap },\n            ])\n          );\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach((directive) => {\n          if (directive.name.value === \"export\" && directive.arguments) {\n            directive.arguments.forEach((arg) => {\n              if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      const isClientField =\n        field.directives?.some((d) => d.name.value === \"client\") ?? false;\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(\n          field,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    result: any[],\n    execContext: ExecContext\n  ): any {\n    return Promise.all(\n      result.map((item) => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(\n            field,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(\n            field.selectionSet,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n      })\n    );\n  }\n\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  private collectSelectionsToResolve(\n    mainDefinition: OperationDefinitionNode,\n    fragmentMap: FragmentMap\n  ): Set<SelectionNode> {\n    const isSingleASTNode = (\n      node: ASTNode | readonly ASTNode[]\n    ): node is ASTNode => !Array.isArray(node);\n    const selectionsToResolveCache = this.selectionsToResolveCache;\n\n    function collectByDefinition(\n      definitionNode: ExecutableDefinitionNode\n    ): Set<SelectionNode> {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        const matches = new Set<SelectionNode>();\n        selectionsToResolveCache.set(definitionNode, matches);\n\n        visit(definitionNode, {\n          Directive(node: DirectiveNode, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread(spread: FragmentSpreadNode, _, __, ___, ancestors) {\n            const fragment = fragmentMap[spread.name.value];\n            invariant(fragment, `No fragment named %s`, spread.name.value);\n\n            const fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n              matches.add(spread);\n              fragmentSelections.forEach((selection) => {\n                matches.add(selection);\n              });\n            }\n          },\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode)!;\n    }\n    return collectByDefinition(mainDefinition);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}