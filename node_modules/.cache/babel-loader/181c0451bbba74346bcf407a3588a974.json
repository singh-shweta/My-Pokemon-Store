{"ast":null,"code":"import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude, isNonNullObject, compact, createFragmentMap, getFragmentDefinitions, isArray } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function isNullish(value) {\n  return value === null || value === void 0;\n}\nexport { isArray };\nexport function defaultDataIdFromObject(_a, context) {\n  var __typename = _a.__typename,\n    id = _a.id,\n    _id = _a._id;\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = !isNullish(id) ? {\n        id: id\n      } : !isNullish(_id) ? {\n        _id: _id\n      } : void 0;\n    }\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n    if (!isNullish(id)) {\n      return \"\".concat(__typename, \":\").concat(typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n    }\n  }\n}\nvar defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false\n};\nexport function normalizeConfig(config) {\n  return compact(defaultConfig, config);\n}\nexport function shouldCanonizeResults(config) {\n  var value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  var match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (isNonNullObject(result)) {\n    return isArray(result) ? result.every(function (item) {\n      return selectionSetMatchesResult(selectionSet, item, variables);\n    }) : selectionSet.selections.every(function (field) {\n      if (isField(field) && shouldInclude(field, variables)) {\n        var key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n      // If the selection has been skipped with @skip(true) or\n      // @include(false), it should not count against the matching. If\n      // the selection is not a field, it must be a fragment (inline or\n      // named). We will determine if selectionSetMatchesResult for that\n      // fragment when we get to it, so for now we return true.\n      return true;\n    });\n  }\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\nexport function extractFragmentContext(document, fragments) {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  var fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap: fragmentMap,\n    lookupFragment: function (name) {\n      var def = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/cache/inmemory/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { NormalizedCache, InMemoryCacheConfig } from \"./types.js\";\n\nimport type { KeyFieldsContext } from \"./policies.js\";\nimport type { FragmentRegistryAPI } from \"./fragmentRegistry.js\";\n\nimport type {\n  Reference,\n  StoreValue,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isReference,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n  createFragmentMap,\n  getFragmentDefinitions,\n  isArray,\n} from \"../../utilities/index.js\";\n\nexport const { hasOwnProperty: hasOwn } = Object.prototype;\n\nexport function isNullish(value: any): value is null | undefined {\n  return value === null || value === void 0;\n}\n\nexport { isArray };\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        !isNullish(id) ? { id }\n        : !isNullish(_id) ? { _id }\n        : void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return `${__typename}:${\n        typeof id === \"number\" || typeof id === \"string\" ?\n          id\n        : JSON.stringify(id)\n      }`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference\n): string | undefined {\n  return isReference(objectOrReference) ?\n      (store.get(objectOrReference.__ref, \"__typename\") as string)\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result) ?\n        result.every((item) =>\n          selectionSetMatchesResult(selectionSet, item, variables)\n        )\n      : selectionSet.selections.every((field) => {\n          if (isField(field) && shouldInclude(field, variables)) {\n            const key = resultKeyNameFromField(field);\n            return (\n              hasOwn.call(result, key) &&\n              (!field.selectionSet ||\n                selectionSetMatchesResult(\n                  field.selectionSet,\n                  result[key],\n                  variables\n                ))\n            );\n          }\n          // If the selection has been skipped with @skip(true) or\n          // @include(false), it should not count against the matching. If\n          // the selection is not a field, it must be a fragment (inline or\n          // named). We will determine if selectionSetMatchesResult for that\n          // fragment when we get to it, so for now we return true.\n          return true;\n        });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue\n): value is StoreObject {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}