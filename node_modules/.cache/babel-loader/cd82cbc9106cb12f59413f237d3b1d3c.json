{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { responseIterator } from \"./responseIterator.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function readMultipartBody(response, nextValue) {\n  return __awaiter(this, void 0, void 0, function () {\n    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next;\n    var _b, _c;\n    var _d;\n    return __generator(this, function (_e) {\n      switch (_e.label) {\n        case 0:\n          if (TextDecoder === undefined) {\n            throw new Error(\"TextDecoder must be defined in the environment: please import a polyfill.\");\n          }\n          decoder = new TextDecoder(\"utf-8\");\n          contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get(\"content-type\");\n          delimiter = \"boundary=\";\n          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['\"]/g, \"\").replace(/\\;(.*)/gm, \"\").trim() : \"-\";\n          boundary = \"\\r\\n--\".concat(boundaryVal);\n          buffer = \"\";\n          iterator = responseIterator(response);\n          running = true;\n          _e.label = 1;\n        case 1:\n          if (!running) return [3 /*break*/, 3];\n          return [4 /*yield*/, iterator.next()];\n        case 2:\n          _a = _e.sent(), value = _a.value, done = _a.done;\n          chunk = typeof value === \"string\" ? value : decoder.decode(value);\n          searchFrom = buffer.length - boundary.length + 1;\n          running = !done;\n          buffer += chunk;\n          bi = buffer.indexOf(boundary, searchFrom);\n          while (bi > -1) {\n            message = void 0;\n            _b = [buffer.slice(0, bi), buffer.slice(bi + boundary.length)], message = _b[0], buffer = _b[1];\n            i = message.indexOf(\"\\r\\n\\r\\n\");\n            headers = parseHeaders(message.slice(0, i));\n            contentType_1 = headers[\"content-type\"];\n            if (contentType_1 && contentType_1.toLowerCase().indexOf(\"application/json\") === -1) {\n              throw new Error(\"Unsupported patch content type: application/json is required.\");\n            }\n            body = message.slice(i);\n            if (body) {\n              result = parseJsonBody(response, body);\n              if (Object.keys(result).length > 1 || \"data\" in result || \"incremental\" in result || \"errors\" in result || \"payload\" in result) {\n                if (isApolloPayloadResult(result)) {\n                  next = {};\n                  if (\"payload\" in result) {\n                    if (Object.keys(result).length === 1 && result.payload === null) {\n                      return [2 /*return*/];\n                    }\n                    next = __assign({}, result.payload);\n                  }\n                  if (\"errors\" in result) {\n                    next = __assign(__assign({}, next), {\n                      extensions: __assign(__assign({}, \"extensions\" in next ? next.extensions : null), (_c = {}, _c[PROTOCOL_ERRORS_SYMBOL] = result.errors, _c))\n                    });\n                  }\n                  nextValue(next);\n                } else {\n                  // for the last chunk with only `hasNext: false`\n                  // we don't need to call observer.next as there is no data/errors\n                  nextValue(result);\n                }\n              } else if (\n              // If the chunk contains only a \"hasNext: false\", we can call\n              // observer.complete() immediately.\n              Object.keys(result).length === 1 && \"hasNext\" in result && !result.hasNext) {\n                return [2 /*return*/];\n              }\n            }\n            bi = buffer.indexOf(boundary);\n          }\n          return [3 /*break*/, 1];\n        case 3:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\nexport function parseHeaders(headerText) {\n  var headersInit = {};\n  headerText.split(\"\\n\").forEach(function (line) {\n    var i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      var name_1 = line.slice(0, i).trim().toLowerCase();\n      var value = line.slice(i + 1).trim();\n      headersInit[name_1] = value;\n    }\n  });\n  return headersInit;\n}\nexport function parseJsonBody(response, bodyText) {\n  if (response.status >= 300) {\n    // Network error\n    var getResult = function () {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(response, getResult(), \"Response not successful: Received status code \".concat(response.status));\n  }\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    var parseError = err;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\nexport function handleError(err, observer) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n  observer.error(err);\n}\nexport function parseAndCheckHttpResponse(operations) {\n  return function (response) {\n    return response.text().then(function (bodyText) {\n      return parseJsonBody(response, bodyText);\n    }).then(function (result) {\n      if (!Array.isArray(result) && !hasOwnProperty.call(result, \"data\") && !hasOwnProperty.call(result, \"errors\")) {\n        // Data error\n        throwServerError(response, result, \"Server response was missing for query '\".concat(Array.isArray(operations) ? operations.map(function (op) {\n          return op.operationName;\n        }) : operations.operationName, \"'.\"));\n      }\n      return result;\n    });\n  };\n}","map":{"version":3,"sources":["../../../src/link/http/parseAndCheckHttpResponse.ts"],"names":[],"mappings":"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","sourcesContent":["import { responseIterator } from \"./responseIterator.js\";\nimport type { Operation } from \"../core/index.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nimport type { SubscriptionObserver } from \"zen-observable-ts\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>,\n>(response: Response, nextValue: (value: T) => void) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal =\n    contentType?.includes(delimiter) ?\n      contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  const boundary = `\\r\\n--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    const searchFrom = buffer.length - boundary.length + 1;\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary, searchFrom);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      const i = message.indexOf(\"\\r\\n\\r\\n\");\n      const headers = parseHeaders(message.slice(0, i));\n      const contentType = headers[\"content-type\"];\n      if (\n        contentType &&\n        contentType.toLowerCase().indexOf(\"application/json\") === -1\n      ) {\n        throw new Error(\n          \"Unsupported patch content type: application/json is required.\"\n        );\n      }\n      // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n      // this is going to be `JSON.parse`d there is no need.\n      const body = message.slice(i);\n\n      if (body) {\n        const result = parseJsonBody<T>(response, body);\n        if (\n          Object.keys(result).length > 1 ||\n          \"data\" in result ||\n          \"incremental\" in result ||\n          \"errors\" in result ||\n          \"payload\" in result\n        ) {\n          if (isApolloPayloadResult(result)) {\n            let next = {};\n            if (\"payload\" in result) {\n              if (Object.keys(result).length === 1 && result.payload === null) {\n                return;\n              }\n              next = { ...result.payload };\n            }\n            if (\"errors\" in result) {\n              next = {\n                ...next,\n                extensions: {\n                  ...(\"extensions\" in next ? next.extensions : (null as any)),\n                  [PROTOCOL_ERRORS_SYMBOL]: result.errors,\n                },\n              };\n            }\n            nextValue(next as T);\n          } else {\n            // for the last chunk with only `hasNext: false`\n            // we don't need to call observer.next as there is no data/errors\n            nextValue(result);\n          }\n        } else if (\n          // If the chunk contains only a \"hasNext: false\", we can call\n          // observer.complete() immediately.\n          Object.keys(result).length === 1 &&\n          \"hasNext\" in result &&\n          !result.hasNext\n        ) {\n          return;\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = (): Record<string, unknown> | string => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: SubscriptionObserver<any>) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n\n  observer.error(err);\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations) ?\n                operations.map((op) => op.operationName)\n              : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}