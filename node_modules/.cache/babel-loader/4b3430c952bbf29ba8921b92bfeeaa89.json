{"ast":null,"code":"function noop() {}\nconst defaultDispose = noop;\nconst _WeakRef = typeof WeakRef !== \"undefined\" ? WeakRef : function (value) {\n  return {\n    deref: () => value\n  };\n};\nconst _WeakMap = typeof WeakMap !== \"undefined\" ? WeakMap : Map;\nconst _FinalizationRegistry = typeof FinalizationRegistry !== \"undefined\" ? FinalizationRegistry : function () {\n  return {\n    register: noop,\n    unregister: noop\n  };\n};\nconst finalizationBatchSize = 10024;\nexport class WeakCache {\n  constructor(max = Infinity, dispose = defaultDispose) {\n    this.max = max;\n    this.dispose = dispose;\n    this.map = new _WeakMap();\n    this.newest = null;\n    this.oldest = null;\n    this.unfinalizedNodes = new Set();\n    this.finalizationScheduled = false;\n    this.size = 0;\n    this.finalize = () => {\n      const iterator = this.unfinalizedNodes.values();\n      for (let i = 0; i < finalizationBatchSize; i++) {\n        const node = iterator.next().value;\n        if (!node) break;\n        this.unfinalizedNodes.delete(node);\n        const key = node.key;\n        delete node.key;\n        node.keyRef = new _WeakRef(key);\n        this.registry.register(key, node, node);\n      }\n      if (this.unfinalizedNodes.size > 0) {\n        queueMicrotask(this.finalize);\n      } else {\n        this.finalizationScheduled = false;\n      }\n    };\n    this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));\n  }\n  has(key) {\n    return this.map.has(key);\n  }\n  get(key) {\n    const node = this.getNode(key);\n    return node && node.value;\n  }\n  getNode(key) {\n    const node = this.map.get(key);\n    if (node && node !== this.newest) {\n      const {\n        older,\n        newer\n      } = node;\n      if (newer) {\n        newer.older = older;\n      }\n      if (older) {\n        older.newer = newer;\n      }\n      node.older = this.newest;\n      node.older.newer = node;\n      node.newer = null;\n      this.newest = node;\n      if (node === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n    return node;\n  }\n  set(key, value) {\n    let node = this.getNode(key);\n    if (node) {\n      return node.value = value;\n    }\n    node = {\n      key,\n      value,\n      newer: null,\n      older: this.newest\n    };\n    if (this.newest) {\n      this.newest.newer = node;\n    }\n    this.newest = node;\n    this.oldest = this.oldest || node;\n    this.scheduleFinalization(node);\n    this.map.set(key, node);\n    this.size++;\n    return node.value;\n  }\n  clean() {\n    while (this.oldest && this.size > this.max) {\n      this.deleteNode(this.oldest);\n    }\n  }\n  deleteNode(node) {\n    if (node === this.newest) {\n      this.newest = node.older;\n    }\n    if (node === this.oldest) {\n      this.oldest = node.newer;\n    }\n    if (node.newer) {\n      node.newer.older = node.older;\n    }\n    if (node.older) {\n      node.older.newer = node.newer;\n    }\n    this.size--;\n    const key = node.key || node.keyRef && node.keyRef.deref();\n    this.dispose(node.value, key);\n    if (!node.keyRef) {\n      this.unfinalizedNodes.delete(node);\n    } else {\n      this.registry.unregister(node);\n    }\n    if (key) this.map.delete(key);\n  }\n  delete(key) {\n    const node = this.map.get(key);\n    if (node) {\n      this.deleteNode(node);\n      return true;\n    }\n    return false;\n  }\n  scheduleFinalization(node) {\n    this.unfinalizedNodes.add(node);\n    if (!this.finalizationScheduled) {\n      this.finalizationScheduled = true;\n      queueMicrotask(this.finalize);\n    }\n  }\n}","map":{"version":3,"sources":["../src/weak.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["function noop() { }\nconst defaultDispose = noop;\nconst _WeakRef = typeof WeakRef !== \"undefined\"\n    ? WeakRef\n    : function (value) {\n        return { deref: () => value };\n    };\nconst _WeakMap = typeof WeakMap !== \"undefined\" ? WeakMap : Map;\nconst _FinalizationRegistry = typeof FinalizationRegistry !== \"undefined\"\n    ? FinalizationRegistry\n    : function () {\n        return {\n            register: noop,\n            unregister: noop,\n        };\n    };\nconst finalizationBatchSize = 10024;\nexport class WeakCache {\n    constructor(max = Infinity, dispose = defaultDispose) {\n        this.max = max;\n        this.dispose = dispose;\n        this.map = new _WeakMap();\n        this.newest = null;\n        this.oldest = null;\n        this.unfinalizedNodes = new Set();\n        this.finalizationScheduled = false;\n        this.size = 0;\n        this.finalize = () => {\n            const iterator = this.unfinalizedNodes.values();\n            for (let i = 0; i < finalizationBatchSize; i++) {\n                const node = iterator.next().value;\n                if (!node)\n                    break;\n                this.unfinalizedNodes.delete(node);\n                const key = node.key;\n                delete node.key;\n                node.keyRef = new _WeakRef(key);\n                this.registry.register(key, node, node);\n            }\n            if (this.unfinalizedNodes.size > 0) {\n                queueMicrotask(this.finalize);\n            }\n            else {\n                this.finalizationScheduled = false;\n            }\n        };\n        this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));\n    }\n    has(key) {\n        return this.map.has(key);\n    }\n    get(key) {\n        const node = this.getNode(key);\n        return node && node.value;\n    }\n    getNode(key) {\n        const node = this.map.get(key);\n        if (node && node !== this.newest) {\n            const { older, newer } = node;\n            if (newer) {\n                newer.older = older;\n            }\n            if (older) {\n                older.newer = newer;\n            }\n            node.older = this.newest;\n            node.older.newer = node;\n            node.newer = null;\n            this.newest = node;\n            if (node === this.oldest) {\n                this.oldest = newer;\n            }\n        }\n        return node;\n    }\n    set(key, value) {\n        let node = this.getNode(key);\n        if (node) {\n            return (node.value = value);\n        }\n        node = {\n            key,\n            value,\n            newer: null,\n            older: this.newest,\n        };\n        if (this.newest) {\n            this.newest.newer = node;\n        }\n        this.newest = node;\n        this.oldest = this.oldest || node;\n        this.scheduleFinalization(node);\n        this.map.set(key, node);\n        this.size++;\n        return node.value;\n    }\n    clean() {\n        while (this.oldest && this.size > this.max) {\n            this.deleteNode(this.oldest);\n        }\n    }\n    deleteNode(node) {\n        if (node === this.newest) {\n            this.newest = node.older;\n        }\n        if (node === this.oldest) {\n            this.oldest = node.newer;\n        }\n        if (node.newer) {\n            node.newer.older = node.older;\n        }\n        if (node.older) {\n            node.older.newer = node.newer;\n        }\n        this.size--;\n        const key = node.key || (node.keyRef && node.keyRef.deref());\n        this.dispose(node.value, key);\n        if (!node.keyRef) {\n            this.unfinalizedNodes.delete(node);\n        }\n        else {\n            this.registry.unregister(node);\n        }\n        if (key)\n            this.map.delete(key);\n    }\n    delete(key) {\n        const node = this.map.get(key);\n        if (node) {\n            this.deleteNode(node);\n            return true;\n        }\n        return false;\n    }\n    scheduleFinalization(node) {\n        this.unfinalizedNodes.add(node);\n        if (!this.finalizationScheduled) {\n            this.finalizationScheduled = true;\n            queueMicrotask(this.finalize);\n        }\n    }\n}\n//# sourceMappingURL=weak.js.map"]},"metadata":{},"sourceType":"module"}