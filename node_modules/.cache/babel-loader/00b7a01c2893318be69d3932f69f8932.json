{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { equal } from \"@wry/equality\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { ApolloError, Observable } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { toApolloError } from \"./useQuery.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\n/**\n * > Refer to the [Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/) section for a more in-depth overview of `useSubscription`.\n *\n * @example\n * ```jsx\n * const COMMENTS_SUBSCRIPTION = gql`\n *   subscription OnCommentAdded($repoFullName: String!) {\n *     commentAdded(repoFullName: $repoFullName) {\n *       id\n *       content\n *     }\n *   }\n * `;\n *\n * function DontReadTheComments({ repoFullName }) {\n *   const {\n *     data: { commentAdded },\n *     loading,\n *   } = useSubscription(COMMENTS_SUBSCRIPTION, { variables: { repoFullName } });\n *   return <h4>New comment: {!loading && commentAdded.content}</h4>;\n * }\n * ```\n * @remarks\n * #### Consider using `onData` instead of `useEffect`\n *\n * If you want to react to incoming data, please use the `onData` option instead of `useEffect`.\n * State updates you make inside a `useEffect` hook might cause additional rerenders, and `useEffect` is mostly meant for side effects of rendering, not as an event handler.\n * State updates made in an event handler like `onData` might - depending on the React version - be batched and cause only a single rerender.\n *\n * Consider the following component:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const { data, error, loading } = useSubscription(query);\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *\n *   useEffect(() => {\n *     setAccumulatedData((prev) => [...prev, data]);\n *   }, [data]);\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * Instead of using `useEffect` here, we can re-write this component to use the `onData` callback function accepted in `useSubscription`'s `options` object:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *   const { data, error, loading } = useSubscription(\n *     query,\n *     {\n *       onData({ data }) {\n *         setAccumulatedData((prev) => [...prev, data])\n *       }\n *     }\n *   );\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * > ⚠️ **Note:** The `useSubscription` option `onData` is available in Apollo Client >= 3.7. In previous versions, the equivalent option is named `onSubscriptionData`.\n *\n * Now, the first message will be added to the `accumulatedData` array since `onData` is called _before_ the component re-renders. React 18 automatic batching is still in effect and results in a single re-render, but with `onData` we can guarantee each message received after the component mounts is added to `accumulatedData`.\n *\n * @since 3.0.0\n * @param subscription - A GraphQL subscription document parsed into an AST by `gql`.\n * @param options - Options to control how the subscription is executed.\n * @returns Query result object\n */\nexport function useSubscription(subscription, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n  var hasIssuedDeprecationWarningRef = React.useRef(false);\n  var client = useApolloClient(options.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n  if (!hasIssuedDeprecationWarningRef.current) {\n    hasIssuedDeprecationWarningRef.current = true;\n    if (options.onSubscriptionData) {\n      globalThis.__DEV__ !== false && invariant.warn(options.onData ? 53 : 54);\n    }\n    if (options.onSubscriptionComplete) {\n      globalThis.__DEV__ !== false && invariant.warn(options.onComplete ? 55 : 56);\n    }\n  }\n  var skip = options.skip,\n    fetchPolicy = options.fetchPolicy,\n    errorPolicy = options.errorPolicy,\n    shouldResubscribe = options.shouldResubscribe,\n    context = options.context,\n    extensions = options.extensions,\n    ignoreResults = options.ignoreResults;\n  var variables = useDeepMemo(function () {\n    return options.variables;\n  }, [options.variables]);\n  var recreate = function () {\n    return createSubscription(client, subscription, variables, fetchPolicy, errorPolicy, context, extensions);\n  };\n  var _a = React.useState(options.skip ? null : recreate),\n    observable = _a[0],\n    setObservable = _a[1];\n  var recreateRef = React.useRef(recreate);\n  useIsomorphicLayoutEffect(function () {\n    recreateRef.current = recreate;\n  });\n  if (skip) {\n    if (observable) {\n      setObservable(observable = null);\n    }\n  } else if (!observable || (client !== observable.__.client || subscription !== observable.__.query || fetchPolicy !== observable.__.fetchPolicy || errorPolicy !== observable.__.errorPolicy || !equal(variables, observable.__.variables)) && (typeof shouldResubscribe === \"function\" ? !!shouldResubscribe(options) : shouldResubscribe) !== false) {\n    setObservable(observable = recreate());\n  }\n  var optionsRef = React.useRef(options);\n  React.useEffect(function () {\n    optionsRef.current = options;\n  });\n  var fallbackLoading = !skip && !ignoreResults;\n  var fallbackResult = React.useMemo(function () {\n    return {\n      loading: fallbackLoading,\n      error: void 0,\n      data: void 0,\n      variables: variables\n    };\n  }, [fallbackLoading, variables]);\n  var ignoreResultsRef = React.useRef(ignoreResults);\n  useIsomorphicLayoutEffect(function () {\n    // We cannot reference `ignoreResults` directly in the effect below\n    // it would add a dependency to the `useEffect` deps array, which means the\n    // subscription would be recreated if `ignoreResults` changes\n    // As a result, on resubscription, the last result would be re-delivered,\n    // rendering the component one additional time, and re-triggering `onData`.\n    // The same applies to `fetchPolicy`, which results in a new `observable`\n    // being created. We cannot really avoid it in that case, but we can at least\n    // avoid it for `ignoreResults`.\n    ignoreResultsRef.current = ignoreResults;\n  });\n  var ret = useSyncExternalStore(React.useCallback(function (update) {\n    if (!observable) {\n      return function () {};\n    }\n    var subscriptionStopped = false;\n    var variables = observable.__.variables;\n    var client = observable.__.client;\n    var subscription = observable.subscribe({\n      next: function (fetchResult) {\n        var _a, _b;\n        if (subscriptionStopped) {\n          return;\n        }\n        var result = {\n          loading: false,\n          // TODO: fetchResult.data can be null but SubscriptionResult.data\n          // expects TData | undefined only\n          data: fetchResult.data,\n          error: toApolloError(fetchResult),\n          variables: variables\n        };\n        observable.__.setResult(result);\n        if (!ignoreResultsRef.current) update();\n        if (result.error) {\n          (_b = (_a = optionsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a, result.error);\n        } else if (optionsRef.current.onData) {\n          optionsRef.current.onData({\n            client: client,\n            data: result\n          });\n        } else if (optionsRef.current.onSubscriptionData) {\n          optionsRef.current.onSubscriptionData({\n            client: client,\n            subscriptionData: result\n          });\n        }\n      },\n      error: function (error) {\n        var _a, _b;\n        error = error instanceof ApolloError ? error : new ApolloError({\n          protocolErrors: [error]\n        });\n        if (!subscriptionStopped) {\n          observable.__.setResult({\n            loading: false,\n            data: void 0,\n            error: error,\n            variables: variables\n          });\n          if (!ignoreResultsRef.current) update();\n          (_b = (_a = optionsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);\n        }\n      },\n      complete: function () {\n        if (!subscriptionStopped) {\n          if (optionsRef.current.onComplete) {\n            optionsRef.current.onComplete();\n          } else if (optionsRef.current.onSubscriptionComplete) {\n            optionsRef.current.onSubscriptionComplete();\n          }\n        }\n      }\n    });\n    return function () {\n      // immediately stop receiving subscription values, but do not unsubscribe\n      // until after a short delay in case another useSubscription hook is\n      // reusing the same underlying observable and is about to subscribe\n      subscriptionStopped = true;\n      setTimeout(function () {\n        subscription.unsubscribe();\n      });\n    };\n  }, [observable]), function () {\n    return observable && !skip && !ignoreResults ? observable.__.result : fallbackResult;\n  }, function () {\n    return fallbackResult;\n  });\n  var restart = React.useCallback(function () {\n    invariant(!optionsRef.current.skip, 57);\n    setObservable(recreateRef.current());\n  }, [optionsRef, recreateRef]);\n  return React.useMemo(function () {\n    return __assign(__assign({}, ret), {\n      restart: restart\n    });\n  }, [ret, restart]);\n}\nfunction createSubscription(client, query, variables, fetchPolicy, errorPolicy, context, extensions) {\n  var options = {\n    query: query,\n    variables: variables,\n    fetchPolicy: fetchPolicy,\n    errorPolicy: errorPolicy,\n    context: context,\n    extensions: extensions\n  };\n  var __ = __assign(__assign({}, options), {\n    client: client,\n    result: {\n      loading: true,\n      data: void 0,\n      error: void 0,\n      variables: variables\n    },\n    setResult: function (result) {\n      __.result = result;\n    }\n  });\n  var observable = null;\n  return Object.assign(new Observable(function (observer) {\n    // lazily start the subscription when the first observer subscribes\n    // to get around strict mode\n    if (!observable) {\n      observable = client.subscribe(options);\n    }\n    var sub = observable.subscribe(observer);\n    return function () {\n      return sub.unsubscribe();\n    };\n  }), {\n    /**\n     * A tracking object to store details about the observable and the latest result of the subscription.\n     */\n    __: __\n  });\n}","map":{"version":3,"sources":["../../../src/react/hooks/useSubscription.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  NoInfer,\n  SubscriptionHookOptions,\n  SubscriptionResult,\n} from \"../types/types.js\";\nimport type {\n  ApolloClient,\n  DefaultContext,\n  ErrorPolicy,\n  FetchPolicy,\n  FetchResult,\n  OperationVariables,\n} from \"../../core/index.js\";\nimport { ApolloError, Observable } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { toApolloError } from \"./useQuery.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\n\n/**\n * > Refer to the [Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/) section for a more in-depth overview of `useSubscription`.\n *\n * @example\n * ```jsx\n * const COMMENTS_SUBSCRIPTION = gql`\n *   subscription OnCommentAdded($repoFullName: String!) {\n *     commentAdded(repoFullName: $repoFullName) {\n *       id\n *       content\n *     }\n *   }\n * `;\n *\n * function DontReadTheComments({ repoFullName }) {\n *   const {\n *     data: { commentAdded },\n *     loading,\n *   } = useSubscription(COMMENTS_SUBSCRIPTION, { variables: { repoFullName } });\n *   return <h4>New comment: {!loading && commentAdded.content}</h4>;\n * }\n * ```\n * @remarks\n * #### Consider using `onData` instead of `useEffect`\n *\n * If you want to react to incoming data, please use the `onData` option instead of `useEffect`.\n * State updates you make inside a `useEffect` hook might cause additional rerenders, and `useEffect` is mostly meant for side effects of rendering, not as an event handler.\n * State updates made in an event handler like `onData` might - depending on the React version - be batched and cause only a single rerender.\n *\n * Consider the following component:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const { data, error, loading } = useSubscription(query);\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *\n *   useEffect(() => {\n *     setAccumulatedData((prev) => [...prev, data]);\n *   }, [data]);\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * Instead of using `useEffect` here, we can re-write this component to use the `onData` callback function accepted in `useSubscription`'s `options` object:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *   const { data, error, loading } = useSubscription(\n *     query,\n *     {\n *       onData({ data }) {\n *         setAccumulatedData((prev) => [...prev, data])\n *       }\n *     }\n *   );\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * > ⚠️ **Note:** The `useSubscription` option `onData` is available in Apollo Client >= 3.7. In previous versions, the equivalent option is named `onSubscriptionData`.\n *\n * Now, the first message will be added to the `accumulatedData` array since `onData` is called _before_ the component re-renders. React 18 automatic batching is still in effect and results in a single re-render, but with `onData` we can guarantee each message received after the component mounts is added to `accumulatedData`.\n *\n * @since 3.0.0\n * @param subscription - A GraphQL subscription document parsed into an AST by `gql`.\n * @param options - Options to control how the subscription is executed.\n * @returns Query result object\n */\nexport function useSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SubscriptionHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = Object.create(null)\n) {\n  const hasIssuedDeprecationWarningRef = React.useRef(false);\n  const client = useApolloClient(options.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n\n  if (!hasIssuedDeprecationWarningRef.current) {\n    hasIssuedDeprecationWarningRef.current = true;\n\n    if (options.onSubscriptionData) {\n      invariant.warn(\n        options.onData ?\n          \"'useSubscription' supports only the 'onSubscriptionData' or 'onData' option, but not both. Only the 'onData' option will be used.\"\n        : \"'onSubscriptionData' is deprecated and will be removed in a future major version. Please use the 'onData' option instead.\"\n      );\n    }\n\n    if (options.onSubscriptionComplete) {\n      invariant.warn(\n        options.onComplete ?\n          \"'useSubscription' supports only the 'onSubscriptionComplete' or 'onComplete' option, but not both. Only the 'onComplete' option will be used.\"\n        : \"'onSubscriptionComplete' is deprecated and will be removed in a future major version. Please use the 'onComplete' option instead.\"\n      );\n    }\n  }\n\n  const {\n    skip,\n    fetchPolicy,\n    errorPolicy,\n    shouldResubscribe,\n    context,\n    extensions,\n    ignoreResults,\n  } = options;\n  const variables = useDeepMemo(() => options.variables, [options.variables]);\n\n  const recreate = () =>\n    createSubscription(\n      client,\n      subscription,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      context,\n      extensions\n    );\n\n  let [observable, setObservable] = React.useState(\n    options.skip ? null : recreate\n  );\n\n  const recreateRef = React.useRef(recreate);\n  useIsomorphicLayoutEffect(() => {\n    recreateRef.current = recreate;\n  });\n\n  if (skip) {\n    if (observable) {\n      setObservable((observable = null));\n    }\n  } else if (\n    !observable ||\n    ((client !== observable.__.client ||\n      subscription !== observable.__.query ||\n      fetchPolicy !== observable.__.fetchPolicy ||\n      errorPolicy !== observable.__.errorPolicy ||\n      !equal(variables, observable.__.variables)) &&\n      (typeof shouldResubscribe === \"function\" ?\n        !!shouldResubscribe(options!)\n      : shouldResubscribe) !== false)\n  ) {\n    setObservable((observable = recreate()));\n  }\n\n  const optionsRef = React.useRef(options);\n  React.useEffect(() => {\n    optionsRef.current = options;\n  });\n\n  const fallbackLoading = !skip && !ignoreResults;\n  const fallbackResult = React.useMemo<SubscriptionResult<TData, TVariables>>(\n    () => ({\n      loading: fallbackLoading,\n      error: void 0,\n      data: void 0,\n      variables,\n    }),\n    [fallbackLoading, variables]\n  );\n\n  const ignoreResultsRef = React.useRef(ignoreResults);\n  useIsomorphicLayoutEffect(() => {\n    // We cannot reference `ignoreResults` directly in the effect below\n    // it would add a dependency to the `useEffect` deps array, which means the\n    // subscription would be recreated if `ignoreResults` changes\n    // As a result, on resubscription, the last result would be re-delivered,\n    // rendering the component one additional time, and re-triggering `onData`.\n    // The same applies to `fetchPolicy`, which results in a new `observable`\n    // being created. We cannot really avoid it in that case, but we can at least\n    // avoid it for `ignoreResults`.\n    ignoreResultsRef.current = ignoreResults;\n  });\n\n  const ret = useSyncExternalStore<SubscriptionResult<TData, TVariables>>(\n    React.useCallback(\n      (update) => {\n        if (!observable) {\n          return () => {};\n        }\n\n        let subscriptionStopped = false;\n        const variables = observable.__.variables;\n        const client = observable.__.client;\n        const subscription = observable.subscribe({\n          next(fetchResult) {\n            if (subscriptionStopped) {\n              return;\n            }\n\n            const result = {\n              loading: false,\n              // TODO: fetchResult.data can be null but SubscriptionResult.data\n              // expects TData | undefined only\n              data: fetchResult.data!,\n              error: toApolloError(fetchResult),\n              variables,\n            };\n            observable.__.setResult(result);\n            if (!ignoreResultsRef.current) update();\n\n            if (result.error) {\n              optionsRef.current.onError?.(result.error);\n            } else if (optionsRef.current.onData) {\n              optionsRef.current.onData({\n                client,\n                data: result,\n              });\n            } else if (optionsRef.current.onSubscriptionData) {\n              optionsRef.current.onSubscriptionData({\n                client,\n                subscriptionData: result,\n              });\n            }\n          },\n          error(error) {\n            error =\n              error instanceof ApolloError ? error : (\n                new ApolloError({ protocolErrors: [error] })\n              );\n            if (!subscriptionStopped) {\n              observable.__.setResult({\n                loading: false,\n                data: void 0,\n                error,\n                variables,\n              });\n              if (!ignoreResultsRef.current) update();\n              optionsRef.current.onError?.(error);\n            }\n          },\n          complete() {\n            if (!subscriptionStopped) {\n              if (optionsRef.current.onComplete) {\n                optionsRef.current.onComplete();\n              } else if (optionsRef.current.onSubscriptionComplete) {\n                optionsRef.current.onSubscriptionComplete();\n              }\n            }\n          },\n        });\n\n        return () => {\n          // immediately stop receiving subscription values, but do not unsubscribe\n          // until after a short delay in case another useSubscription hook is\n          // reusing the same underlying observable and is about to subscribe\n          subscriptionStopped = true;\n          setTimeout(() => {\n            subscription.unsubscribe();\n          });\n        };\n      },\n      [observable]\n    ),\n    () =>\n      observable && !skip && !ignoreResults ?\n        observable.__.result\n      : fallbackResult,\n    () => fallbackResult\n  );\n\n  const restart = React.useCallback(() => {\n    invariant(\n      !optionsRef.current.skip,\n      \"A subscription that is skipped cannot be restarted.\"\n    );\n    setObservable(recreateRef.current());\n  }, [optionsRef, recreateRef]);\n\n  return React.useMemo(() => ({ ...ret, restart }), [ret, restart]);\n}\n\nfunction createSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  client: ApolloClient<any>,\n  query: TypedDocumentNode<TData, TVariables>,\n  variables: TVariables | undefined,\n  fetchPolicy: FetchPolicy | undefined,\n  errorPolicy: ErrorPolicy | undefined,\n  context: DefaultContext | undefined,\n  extensions: Record<string, any> | undefined\n) {\n  const options = {\n    query,\n    variables,\n    fetchPolicy,\n    errorPolicy,\n    context,\n    extensions,\n  };\n  const __ = {\n    ...options,\n    client,\n    result: {\n      loading: true,\n      data: void 0,\n      error: void 0,\n      variables,\n    } as SubscriptionResult<TData, TVariables>,\n    setResult(result: SubscriptionResult<TData, TVariables>) {\n      __.result = result;\n    },\n  };\n\n  let observable: Observable<FetchResult<TData>> | null = null;\n  return Object.assign(\n    new Observable<FetchResult<TData>>((observer) => {\n      // lazily start the subscription when the first observer subscribes\n      // to get around strict mode\n      if (!observable) {\n        observable = client.subscribe(options);\n      }\n      const sub = observable.subscribe(observer);\n      return () => sub.unsubscribe();\n    }),\n    {\n      /**\n       * A tracking object to store details about the observable and the latest result of the subscription.\n       */\n      __,\n    }\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}